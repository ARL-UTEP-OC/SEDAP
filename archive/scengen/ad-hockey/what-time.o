  my ($i);
    for ($i = 0; $i < $num_ends; $i++) {
	if ($event_ends[$i]->[$TIME] <= $end_time) {

	    if ($event_ends[$i]->[$TYPE] == $NODE_COLOR) {

		ResetNodeColor($event_ends[$i]->[$OBJECT]);

	    } elsif ($event_ends[$i]->[$TYPE] == $PKT_LINE) {

#print "pkt line $event_ends[$i]->[$DATA] $event_ends[$i]->[$TIME]\n";
		$CANVAS->delete($event_ends[$i]->[$DATA]);
	    }
	    
#print "undisplay $i/$num_ends $event_ends[$i]->[$OBJECT] type $event_ends[$i]->[$TYPE] at $event_ends[$i]->[$TIME]\n";
	    # remove event from queue
	    $event_ends[$i] = $event_ends[$num_ends - 1];
	    $num_ends--;
	    $i--;  
            # yes, I'm frobbing the iteration variable to stutter on this
	    # value of i so that the record we just moved from the end is
	    # checked. Your notions of proper coding style mean nothing to me 
	    # -dam
	}
    }
};

sub DisplayPktEvent {    
    my ($time, $node, $type, $level, $len, $mac_src, $ip_src) = @ARG;
    # note: $mac_src only has meaning for 'r' events (right???)

    if ($show_agt && $node == $ip_src && $level eq 'RTR') {
	return;
    }

    if ($show_rtr && $level eq 'RTR') {

	$CANVAS->itemconfigure('n'.$node, -fill => $rtr_colors{$type});

	if ($show_pkt_lines && $type eq 'r' && $mac_src != 0) {
	    my ($x1, $y1) = $CANVAS->coords('n'.$node);
	    my ($x2, $y2) = $CANVAS->coords('n'.$mac_src);
	    my $tag = $node.'-'.$mac_src;
	    $CANVAS->create('line', 
			    $x1 + $DOT_SIZE, $y1 + $DOT_SIZE,
			    $x2 + $DOT_SIZE, $y2 + $DOT_SIZE,
			    -fill => $conn_color, -tag => $tag);
	    AddEndEvent($time + 5 * ($len * 8)/$LINK_BW, 
			$node, $PKT_LINE, $tag);
	}

    } elsif ($show_agt && $level eq 'AGT') {

	$CANVAS->itemconfigure('n'.$node, -fill => $agt_colors{$type});

    }

    # the end time calc will be slightly wrong, because on sends
    # events the length doesn't include the mac header, but it does
    # on receives
#print "display $node at $time\n";
    AddEndEvent($time + ($len * 8)/$LINK_BW, $node, $NODE_COLOR, 1);
#printf("  -- delay %f\n", ($len * 8)/$LINK_BW);

};

sub DisplayPCTDEvent {
    my $lon = $PCTD_DATA{gps_longitude};
    my $lat = $PCTD_DATA{gps_latitude};
    my $node = $PCTD_DATA{node};
    
    my ($x, $y) = (scale_lon($lon), scale_lat($lat));
    
#    print "t $PCTD_DATA{time} node $node from $lon,$lat to $x,$y\n";
    move_node("n".$node, $x, $y);
};

sub DisplayEventsTill {
    my ($end_time) = @ARG;

    my ($t, $e);
    $t = PeekNextEventTime();
	
    for ($t = PeekNextEventTime(); $t > 0 && $t < $end_time; 
	 $t = PeekNextEventTime()) {

	($t,$e)= GetNextEvent();
	
	if ($e =~ /^([rsf]).*?_(\d+)_ (\w+) .*? (\w+) (\d+) \[\w+ \w+ \w+ (\w+).*?\[(\w+)/) {
	    # $1 is type
	    # $2 is node
	    # $3 is trace level
	    # $4 is the pkt type
	    # $5 is length
	    # $6 is mac source of pkt (hex)
	    # $7 is ip src of pkt
# print "$t $2 $1 $3 $4\n";

	    # ignore ARP event ($7 is REQUEST or REPLY)
	    # it would actually work to call DisplayPkt, since
	    # the ip_src is just used for coloring
	    if ($4 eq 'ARP') {next;}

	    DisplayPktEvent($t,$2,$1,$3,$5,hex($6),$7);

	} elsif ($e =~ /^C \d+.\d+ (.*)$/) {
	    $comment_text->delete('1.0','end');
	    $comment_text->insert('1.0',$1);
	    $comment_text->configure('width' => length($1));
	} elsif ($e eq 'pctd-data') {
	    DisplayPCTDEvent();
	} else {
	    print "DFU: unknown event:\n$e\n";
	    die;
	}
    }
};

###########################################################################
###########################################################################
# Main
###########################################################################
###########################################################################

# stolen from bouncing ball simulation demo widget -dam
# This runs the Tk mainloop. Note that the simulation itself has a main
# loop which must be processed. DoSingleStep runs a bit of the simulation
# during every iteration. Also note  that, with a flag of 0,
# Tk::DoOneEvent will suspend the  process until an X-event arrives, 
# effectively blocking the  while loop. 

##########################################################################
### arg processing

my $controls_on_main_window = 1;
my $geometry = '';
my $autostart = 0;

sub usage {
    print "usage: ad-hockey [-slowdown %d | -sl %d] [-geometry ...] \n";
    print "                 [-autostart] [-autorewind]\n";
    print "                 [-comment 'mumble mumble']\n";
    print "                 [-show-range | -sr] [-no-controls | -nc]\n";
    print "                 [<scenario file>] [<trace file>] \n";
    exit;
}

while ($#ARGV >= 0) {
    if ($ARGV[0] eq '-sl' || $ARGV[0] eq '-slowdown') {
	# assume simple slowdown model 
	$default_slowdown = $ARGV[1];
	shift; shift;
    } elsif  ($ARGV[0] eq '-geometry') {
	$geometry = $ARGV[1];
	shift; shift;
    } elsif  ($ARGV[0] eq '-comment') {
	$default_comment = $ARGV[1];
	shift; shift;
    } elsif